"""
Report Generation Module

This module generates comprehensive reports about the PA form filling process,
including missing fields analysis, confidence scores, and recommendations.
"""

import os
import json
import sys
from typing import Dict, List, Any, Optional
from datetime import datetime
from loguru import logger

# Add current directory to path for local imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from utils import setup_logging, ensure_directory_exists


class ReportGenerator:
    """
    Main class for generating PA processing reports.
    """
    
    def __init__(self):
        """Initialize the report generator."""
        self.report_template = """
# Prior Authorization Processing Report

**Generated:** {timestamp}
**Patient:** {patient_id}
**Source Files:**
- PA Form: `{pa_form}`
- Referral Package: `{referral_package}`

---

## Executive Summary

- **Form Type:** {form_type}
- **Total Fields:** {total_fields}
- **Successfully Filled:** {filled_count} ({fill_percentage:.1f}%)
- **Missing Fields:** {missing_count}
- **Processing Status:** {status}

---

## Extraction Results

### Data Successfully Extracted
{extracted_data_summary}

### Confidence Scores
{confidence_scores}

---

## Form Filling Results

### Successfully Filled Fields
{filled_fields_summary}

### Missing Fields Analysis
{missing_fields_analysis}

---

## Recommendations

{recommendations}

---

## Technical Details

### Extraction Method
- **Primary Method:** {extraction_method}
- **OCR Used:** {ocr_used}
- **Processing Time:** {processing_time}

### Processing Errors
{processing_errors}

### Raw Statistics
```json
{raw_statistics}
```

---

## Data Quality Assessment

{data_quality_assessment}

---

*Report generated by Mandolin PA Pipeline v1.0*
"""
    
    def generate_comprehensive_report(self, 
                                    patient_id: str,
                                    extraction_results: Dict[str, Any],
                                    filling_results: Dict[str, Any],
                                    pa_form_path: str,
                                    referral_path: str,
                                    output_path: str) -> bool:
        """
        Generate a comprehensive processing report.
        
        Args:
            patient_id: Patient identifier
            extraction_results: Results from referral data extraction
            filling_results: Results from PA form filling
            pa_form_path: Path to the PA form
            referral_path: Path to the referral package
            output_path: Path for the output report
            
        Returns:
            True if report generation was successful
        """
        try:
            logger.info(f"Generating comprehensive report for patient {patient_id}")
            
            # Prepare report data
            report_data = self._prepare_report_data(
                patient_id, extraction_results, filling_results, 
                pa_form_path, referral_path
            )
            
            # Generate report content
            report_content = self._format_report(report_data)
            
            # Save report
            ensure_directory_exists(os.path.dirname(output_path))
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            logger.info(f"Report generated successfully: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to generate report: {e}")
            return False
    
    def generate_missing_fields_report(self, 
                                     missing_fields: List[Dict[str, Any]], 
                                     output_path: str,
                                     patient_id: Optional[str] = None) -> bool:
        """
        Generate a focused missing fields report.
        
        Args:
            missing_fields: List of missing field information
            output_path: Path for the output report
            patient_id: Optional patient identifier
            
        Returns:
            True if report generation was successful
        """
        try:
            logger.info("Generating missing fields report")
            
            content = f"# Missing Fields Report\n\n"
            
            if patient_id:
                content += f"**Patient ID:** {patient_id}\n"
            
            content += f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            
            if not missing_fields:
                content += "‚úÖ **All fields were successfully filled!**\n"
            else:
                content += f"## Summary\n\n"
                content += f"- **Total Missing Fields:** {len(missing_fields)}\n\n"
                
                # Group by reason
                reason_groups = {}
                for field in missing_fields:
                    reason = field.get('reason', 'Unknown')
                    if reason not in reason_groups:
                        reason_groups[reason] = []
                    reason_groups[reason].append(field)
                
                content += f"## Missing Fields by Category\n\n"
                
                for reason, fields in reason_groups.items():
                    content += f"### {reason} ({len(fields)} fields)\n\n"
                    for field in fields:
                        field_name = field.get('field_name', 'Unknown')
                        field_type = field.get('field_type', 'text')
                        content += f"- **{field_name}** _{field_type}_\n"
                    content += "\n"
                
                # Add recommendations
                content += self._generate_missing_fields_recommendations(reason_groups)
            
            # Save report
            ensure_directory_exists(os.path.dirname(output_path))
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Missing fields report generated: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to generate missing fields report: {e}")
            return False
    
    def _prepare_report_data(self, 
                           patient_id: str,
                           extraction_results: Dict[str, Any],
                           filling_results: Dict[str, Any],
                           pa_form_path: str,
                           referral_path: str) -> Dict[str, Any]:
        """Prepare data for report generation."""
        
        # Calculate statistics
        total_extracted_fields = sum(
            len(section) for section in extraction_results.values() 
            if isinstance(section, dict)
        )
        
        extraction_errors = extraction_results.get('extraction_errors', [])
        processing_errors = filling_results.get('processing_errors', [])
        
        status = "SUCCESS"
        if extraction_errors or processing_errors:
            status = "COMPLETED_WITH_ERRORS"
        if filling_results.get('filled_count', 0) == 0:
            status = "FAILED"
        
        return {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'patient_id': patient_id,
            'pa_form': os.path.basename(pa_form_path),
            'referral_package': os.path.basename(referral_path),
            'form_type': filling_results.get('form_type', 'unknown'),
            'total_fields': filling_results.get('total_fields', 0),
            'filled_count': filling_results.get('filled_count', 0),
            'fill_percentage': filling_results.get('fill_percentage', 0.0),
            'missing_count': len(filling_results.get('missing_fields', [])),
            'status': status,
            'extraction_method': extraction_results.get('metadata', {}).get('extraction_method', 'Unknown'),
            'ocr_used': 'OCR' in extraction_results.get('metadata', {}).get('extraction_method', ''),
            'processing_time': 'N/A',  # Would need to track this separately
            'total_extracted_fields': total_extracted_fields,
            'extraction_results': extraction_results,
            'filling_results': filling_results
        }
    
    def _format_report(self, data: Dict[str, Any]) -> str:
        """Format the report using the template."""
        
        # Format extracted data summary
        extracted_data_summary = self._format_extracted_data_summary(data['extraction_results'])
        
        # Format confidence scores
        confidence_scores = self._format_confidence_scores(data['extraction_results'])
        
        # Format filled fields summary
        filled_fields_summary = self._format_filled_fields_summary(data['filling_results'])
        
        # Format missing fields analysis
        missing_fields_analysis = self._format_missing_fields_analysis(data['filling_results'])
        
        # Generate recommendations
        recommendations = self._generate_recommendations(data)
        
        # Format processing errors
        processing_errors = self._format_processing_errors(data)
        
        # Format raw statistics
        raw_statistics = self._format_raw_statistics(data)
        
        # Generate data quality assessment
        data_quality_assessment = self._generate_data_quality_assessment(data)
        
        # Fill template
        return self.report_template.format(
            timestamp=data['timestamp'],
            patient_id=data['patient_id'],
            pa_form=data['pa_form'],
            referral_package=data['referral_package'],
            form_type=data['form_type'],
            total_fields=data['total_fields'],
            filled_count=data['filled_count'],
            fill_percentage=data['fill_percentage'],
            missing_count=data['missing_count'],
            status=data['status'],
            extraction_method=data['extraction_method'],
            ocr_used="Yes" if data['ocr_used'] else "No",
            processing_time=data['processing_time'],
            extracted_data_summary=extracted_data_summary,
            confidence_scores=confidence_scores,
            filled_fields_summary=filled_fields_summary,
            missing_fields_analysis=missing_fields_analysis,
            recommendations=recommendations,
            processing_errors=processing_errors,
            raw_statistics=raw_statistics,
            data_quality_assessment=data_quality_assessment
        )
    
    def _format_extracted_data_summary(self, extraction_results: Dict[str, Any]) -> str:
        """Format the extracted data summary section."""
        content = ""
        
        categories = ['patient_info', 'clinical_info', 'insurance_info', 'prescriber_info']
        
        for category in categories:
            if category in extraction_results and extraction_results[category]:
                category_name = category.replace('_', ' ').title()
                content += f"\n#### {category_name}\n\n"
                
                for field, value in extraction_results[category].items():
                    content += f"- **{field}:** {value}\n"
                
                content += "\n"
        
        return content if content else "_No structured data was extracted._"
    
    def _format_confidence_scores(self, extraction_results: Dict[str, Any]) -> str:
        """Format confidence scores section."""
        scores = extraction_results.get('metadata', {}).get('confidence_scores', {})
        
        if not scores:
            return "_No confidence scores available._"
        
        content = "\n| Field | Confidence Score |\n|-------|------------------|\n"
        
        for field, score in sorted(scores.items(), key=lambda x: x[1], reverse=True):
            confidence_level = "üü¢ High" if score >= 0.8 else "üü° Medium" if score >= 0.6 else "üî¥ Low"
            content += f"| {field} | {score:.2f} ({confidence_level}) |\n"
        
        return content
    
    def _format_filled_fields_summary(self, filling_results: Dict[str, Any]) -> str:
        """Format filled fields summary."""
        filled_fields = filling_results.get('filled_fields', {})
        
        if not filled_fields:
            return "_No fields were successfully filled._"
        
        content = "\n"
        for field, value in filled_fields.items():
            content += f"- **{field}:** {value}\n"
        
        return content
    
    def _format_missing_fields_analysis(self, filling_results: Dict[str, Any]) -> str:
        """Format missing fields analysis."""
        missing_fields = filling_results.get('missing_fields', [])
        
        if not missing_fields:
            return "üéâ **All form fields were successfully filled!**"
        
        # Group by reason
        reason_groups = {}
        for field in missing_fields:
            reason = field.get('reason', 'Unknown')
            if reason not in reason_groups:
                reason_groups[reason] = []
            reason_groups[reason].append(field)
        
        content = "\n"
        for reason, fields in reason_groups.items():
            content += f"#### {reason} ({len(fields)} fields)\n\n"
            for field in fields:
                field_name = field.get('field_name', 'Unknown')
                field_type = field.get('field_type', 'text')
                content += f"- **{field_name}** _{field_type}_\n"
            content += "\n"
        
        return content
    
    def _generate_recommendations(self, data: Dict[str, Any]) -> str:
        """Generate recommendations based on processing results."""
        recommendations = []
        
        fill_percentage = data['fill_percentage']
        extraction_results = data['extraction_results']
        filling_results = data['filling_results']
        
        # Overall performance recommendations
        if fill_percentage >= 90:
            recommendations.append("‚úÖ **Excellent:** Form filling performance is excellent (‚â•90%).")
        elif fill_percentage >= 70:
            recommendations.append("‚ö†Ô∏è **Good:** Form filling performance is good (‚â•70%), but there's room for improvement.")
        else:
            recommendations.append("üî¥ **Needs Attention:** Form filling performance is below expectations (<70%).")
        
        # OCR quality recommendations
        if data['ocr_used']:
            raw_text_length = len(extraction_results.get('raw_text', ''))
            if raw_text_length < 1000:
                recommendations.append("üìÑ **OCR Quality:** Consider improving image quality for better OCR results. Current text extraction seems limited.")
        
        # Missing fields recommendations
        missing_fields = filling_results.get('missing_fields', [])
        if missing_fields:
            reason_counts = {}
            for field in missing_fields:
                reason = field.get('reason', 'Unknown')
                reason_counts[reason] = reason_counts.get(reason, 0) + 1
            
            top_reason = max(reason_counts.items(), key=lambda x: x[1])
            if top_reason[0] == "No matching data found":
                recommendations.append("üîç **Data Extraction:** Most missing fields are due to data not being found. Consider reviewing extraction patterns or improving OCR quality.")
            elif "Low confidence" in top_reason[0]:
                recommendations.append("üìä **Confidence:** Many fields have low confidence matches. Consider manually reviewing these fields.")
        
        # Form type specific recommendations
        if data['form_type'] == 'non-widget':
            recommendations.append("üìù **Form Type:** This is a non-widget form. Consider requesting widget-based forms for better accuracy.")
        
        # Processing errors recommendations
        processing_errors = data['extraction_results'].get('extraction_errors', []) + data['filling_results'].get('processing_errors', [])
        if processing_errors:
            recommendations.append("‚ö†Ô∏è **Errors:** Processing errors were encountered. Review the technical details section for more information.")
        
        content = "\n"
        for i, rec in enumerate(recommendations, 1):
            content += f"{i}. {rec}\n\n"
        
        return content if content.strip() else "_No specific recommendations at this time._"
    
    def _format_processing_errors(self, data: Dict[str, Any]) -> str:
        """Format processing errors section."""
        extraction_errors = data['extraction_results'].get('extraction_errors', [])
        filling_errors = data['filling_results'].get('processing_errors', [])
        
        all_errors = extraction_errors + filling_errors
        
        if not all_errors:
            return "_No processing errors occurred._"
        
        content = "\n"
        for i, error in enumerate(all_errors, 1):
            content += f"{i}. {error}\n"
        
        return content
    
    def _format_raw_statistics(self, data: Dict[str, Any]) -> str:
        """Format raw statistics as JSON."""
        stats = {
            'total_fields': data['total_fields'],
            'filled_fields': data['filled_count'],
            'missing_fields': data['missing_count'],
            'fill_percentage': data['fill_percentage'],
            'extraction_method': data['extraction_method'],
            'form_type': data['form_type'],
            'total_extracted_data_points': data['total_extracted_fields']
        }
        
        return json.dumps(stats, indent=2)
    
    def _generate_data_quality_assessment(self, data: Dict[str, Any]) -> str:
        """Generate data quality assessment."""
        confidence_scores = data['extraction_results'].get('metadata', {}).get('confidence_scores', {})
        
        if not confidence_scores:
            return "_Data quality assessment not available._"
        
        # Calculate average confidence
        avg_confidence = sum(confidence_scores.values()) / len(confidence_scores)
        
        # Count by confidence level
        high_conf = sum(1 for score in confidence_scores.values() if score >= 0.8)
        medium_conf = sum(1 for score in confidence_scores.values() if 0.6 <= score < 0.8)
        low_conf = sum(1 for score in confidence_scores.values() if score < 0.6)
        
        quality_level = "High" if avg_confidence >= 0.8 else "Medium" if avg_confidence >= 0.6 else "Low"
        
        content = f"""
**Overall Data Quality:** {quality_level} (Average Confidence: {avg_confidence:.2f})

**Confidence Distribution:**
- üü¢ High Confidence (‚â•0.8): {high_conf} fields
- üü° Medium Confidence (0.6-0.8): {medium_conf} fields  
- üî¥ Low Confidence (<0.6): {low_conf} fields

**Assessment:** """
        
        if avg_confidence >= 0.8:
            content += "Excellent data quality. Most extracted information is highly reliable."
        elif avg_confidence >= 0.6:
            content += "Good data quality with some fields requiring review."
        else:
            content += "Data quality needs improvement. Manual review recommended for most fields."
        
        return content
    
    def _generate_missing_fields_recommendations(self, reason_groups: Dict[str, List[Dict]]) -> str:
        """Generate recommendations for missing fields."""
        content = "## Recommendations\n\n"
        
        for reason, fields in reason_groups.items():
            if "No matching data found" in reason:
                content += f"### For '{reason}' fields:\n"
                content += "- Review the referral package to ensure all necessary information is included\n"
                content += "- Check if data might be in a different format or location\n"
                content += "- Consider manual entry for critical fields\n\n"
            
            elif "Low confidence" in reason:
                content += f"### For '{reason}' fields:\n"
                content += "- Manually review extracted values for accuracy\n"
                content += "- Improve image quality if using OCR\n"
                content += "- Consider updating extraction patterns\n\n"
            
            elif "choice" in reason.lower():
                content += f"### For choice field issues:\n"
                content += "- Review available options in the form\n"
                content += "- Check for spelling variations or abbreviations\n"
                content += "- Consider mapping common variations to form options\n\n"
        
        return content


def generate_comprehensive_report(patient_id: str,
                                extraction_results: Dict[str, Any],
                                filling_results: Dict[str, Any],
                                pa_form_path: str,
                                referral_path: str,
                                output_path: str) -> bool:
    """
    Generate a comprehensive processing report.
    
    Args:
        patient_id: Patient identifier
        extraction_results: Results from referral data extraction
        filling_results: Results from PA form filling
        pa_form_path: Path to the PA form
        referral_path: Path to the referral package
        output_path: Path for the output report
        
    Returns:
        True if successful
    """
    setup_logging()
    
    generator = ReportGenerator()
    return generator.generate_comprehensive_report(
        patient_id, extraction_results, filling_results,
        pa_form_path, referral_path, output_path
    )


def generate_missing_fields_report(missing_fields: List[Dict[str, Any]], 
                                 output_path: str,
                                 patient_id: Optional[str] = None) -> bool:
    """
    Generate a focused missing fields report.
    
    Args:
        missing_fields: List of missing field information
        output_path: Path for the output report
        patient_id: Optional patient identifier
        
    Returns:
        True if successful
    """
    setup_logging()
    
    generator = ReportGenerator()
    return generator.generate_missing_fields_report(missing_fields, output_path, patient_id)


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 3:
        print("Usage: python generate_report.py <missing_fields_json> <output_path> [patient_id]")
        sys.exit(1)
    
    missing_fields_path = sys.argv[1]
    output_path = sys.argv[2]
    patient_id = sys.argv[3] if len(sys.argv) > 3 else None
    
    # Load missing fields data
    try:
        with open(missing_fields_path, 'r', encoding='utf-8') as f:
            missing_fields = json.load(f)
    except Exception as e:
        print(f"Error loading missing fields data: {e}")
        sys.exit(1)
    
    # Generate report
    success = generate_missing_fields_report(missing_fields, output_path, patient_id)
    
    if success:
        print(f"Report generated successfully: {output_path}")
    else:
        print("Report generation failed") 